"""
ì¹´ë“œë‰´ìŠ¤ ë¶„ì„ ëŒ€ì‹œë³´ë“œ í†µí•© ëª¨ë“ˆ
ì‘ì„±ì¼: 2025-06-13
ëª©ì : section_analytics.pyì˜ ê¸°ëŠ¥ì„ Streamlit UIì— í†µí•©

import streamlit as st
import pandas as pd
try:
    import plotly.express as px
    import plotly.graph_objects as go
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False
    print("âš ï¸ Plotly not installed. Analytics features will be limited.")
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Union
import json
from card_news.section_analytics import SectionAnalytics
from card_news.section_config import SectionConfig
class AnalyticsDashboard:
    """Streamlit UIìš© ë¶„ì„ ëŒ€ì‹œë³´ë“œ"""
    
    def __init__(self):
        self.analytics = SectionAnalytics()
        self.config = SectionConfig()
    def render_mini_dashboard(self, article_keywords: List[str]) -> Dict[str, float]:
        """
        ì¹´ë“œë‰´ìŠ¤ ìƒì„± í™”ë©´ì— í‘œì‹œí•  ë¯¸ë‹ˆ ëŒ€ì‹œë³´ë“œ
        Returns: ì„¹ì…˜ë³„ ì‹ ë¢°ë„ ì ìˆ˜
        """
        if not PLOTLY_AVAILABLE:
            return {}
        # ì„¹ì…˜ ì‹ ë¢°ë„ ê³„ì‚°
        section_reliability = self.analytics.get_section_reliability()
        
        # í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ì²œ
        keyword_recommendations = {}
        for keyword in article_keywords:
            best_sections = self.analytics.get_best_sections_for_keyword(keyword, top_n=3)
            for section, score in best_sections:
                if section not in keyword_recommendations:
                    keyword_recommendations[section] = []
                keyword_recommendations[section].append((keyword, score))
        # ë¯¸ë‹ˆ ëŒ€ì‹œë³´ë“œ ë Œë”ë§
        with st.container():
            st.markdown("### ğŸ“Š ì„¹ì…˜ ë¶„ì„ ì¸ì‚¬ì´íŠ¸")
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("**ğŸ¯ ì„¹ì…˜ ì‹ ë¢°ë„**")
                reliability_df = pd.DataFrame([
                    {"ì„¹ì…˜": self.config.SECTIONS[section].get('title', section), 
                     "ì‹ ë¢°ë„": f"{score:.1%}"}
                    for section, score in sorted(
                        section_reliability.items(), 
                        key=lambda x: x[1], 
                        reverse=True
                    )[:5]
                ])
                st.dataframe(reliability_df, hide_index=True, use_container_width=True)
            with col2:
                st.markdown("**ğŸ” í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ì²œ**")
                for section, keywords in list(keyword_recommendations.items())[:3]:
                    section_name = self.config.SECTIONS.get(section, {}).get('title', section)
                    keywords_str = ", ".join([f"{kw}" for kw, _ in keywords[:2]])
                    st.info(f"**{section_name}**: {keywords_str}")
        return section_reliability
    def render_quality_feedback(self, article_id: str, selected_sections: List[str]):
        """í’ˆì§ˆ í”¼ë“œë°± UI"""
        st.markdown("### ğŸ“ ì¹´ë“œë‰´ìŠ¤ í’ˆì§ˆ í‰ê°€")
        
        feedback_data = {}
        
        # ì „ì²´ ë§Œì¡±ë„
        overall_rating = st.slider(
            "ì „ì²´ ë§Œì¡±ë„",
            min_value=1,
            max_value=10,
            value=7,
            help="ìƒì„±ëœ ì¹´ë“œë‰´ìŠ¤ì˜ ì „ì²´ì ì¸ í’ˆì§ˆì„ í‰ê°€í•´ì£¼ì„¸ìš”"
        )
        feedback_data['overall_rating'] = overall_rating
        
        # ì„¹ì…˜ë³„ í‰ê°€
        st.markdown("**ì„¹ì…˜ë³„ ì í•©ë„ í‰ê°€**")
        section_ratings = {}
        
        cols = st.columns(min(len(selected_sections), 3))
        for idx, section in enumerate(selected_sections):
            with cols[idx % 3]:
                section_name = self.config.SECTIONS.get(section, {}).get('title', section)
                rating = st.select_slider(
                    section_name,
                    options=['ë‚®ìŒ', 'ë³´í†µ', 'ë†’ìŒ'],
                    value='ë³´í†µ',
                    key=f"section_rating_{section}"
                )
                section_ratings[section] = {'ë‚®ìŒ': 3, 'ë³´í†µ': 7, 'ë†’ìŒ': 10}[rating]
        
        feedback_data['section_ratings'] = section_ratings
        
        # í”¼ë“œë°± ì €ì¥
        if st.button("ğŸ’¾ í‰ê°€ ì €ì¥", type="primary"):
            self.analytics.save_quality_feedback(
                article_id=article_id,
                overall_rating=overall_rating,
                section_ratings=section_ratings,
                timestamp=datetime.now().isoformat()
            )
            st.success("âœ… í‰ê°€ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!")
            
            # ë¶„ì„ ë¦¬í¬íŠ¸ ì—…ë°ì´íŠ¸
            self.analytics.generate_weekly_report()
    
    def get_optimized_sections(self, article_keywords: List[str], 
                             original_sections: Union[List[str], List[Tuple[str, int]]]) -> Tuple[List[str], Dict[str, str]]:
        """
        if not PLOTLY_AVAILABLE:
            return {}
        ë¶„ì„ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìµœì í™”ëœ ì„¹ì…˜ ì œì•ˆ
        Returns: (optimized_sections, reasons)
        reliability = self.analytics.get_section_reliability()
        optimized = []
        reasons = {}
        # original_sections ì •ê·œí™” (ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜)
        normalized_sections = []
        for section in original_sections:
            if isinstance(section, str):
                normalized_sections.append(section)
            elif isinstance(section, (tuple, list)) and len(section) > 0:
                # íŠœí”Œì´ë‚˜ ë¦¬ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ ìš”ì†Œ ì‚¬ìš©
                section_id = section[0]
                # section_idê°€ ë¦¬ìŠ¤íŠ¸ì¸ ê²½ìš° ì²˜ë¦¬
                if isinstance(section_id, list):
                    section_id = str(section_id[0]) if section_id else 'unknown'
                normalized_sections.append(str(section_id))
            else:
                continue
        # 1. ê³ ì„±ëŠ¥ ì„¹ì…˜ ìš°ì„  í¬í•¨
        for section in normalized_sections:
            if reliability.get(section, 0) >= 0.7:  # ì‹ ë¢°ë„ 70% ì´ìƒ
                optimized.append(section)
                # 2. ì €ì„±ëŠ¥ ì„¹ì…˜ì€ ëŒ€ì²´ ì„¹ì…˜ ì°¾ê¸°
                alternative = self._find_alternative_section(section, article_keywords)
                if alternative:
                    optimized.append(alternative)
                    reasons[alternative] = f"{section} ëŒ€ì‹  ì¶”ì²œ (ì‹ ë¢°ë„: {reliability.get(alternative, 0):.1%})"
        # 3. í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ê°€ ì„¹ì…˜ ì œì•ˆ
        for keyword in article_keywords[:3]:  # ìƒìœ„ 3ê°œ í‚¤ì›Œë“œë§Œ
            best_sections = self.analytics.get_best_sections_for_keyword(keyword, top_n=2)
            for section_tuple in best_sections:
                # íŠœí”Œì—ì„œ ì„¹ì…˜ ID ì¶”ì¶œ
                if isinstance(section_tuple, tuple) and len(section_tuple) >= 2:
                    section = str(section_tuple[0])
                    score = section_tuple[1]
                else:
                    continue
                    
                if section not in optimized and len(optimized) < 5:
                    optimized.append(section)
                    reasons[section] = f"í‚¤ì›Œë“œ '{keyword}' ë§¤ì¹­ (ì ìˆ˜: {score:.1f})"
        # ìµœì¢… ë°˜í™˜ê°’ë„ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ì„ì„ ë³´ì¥
        return [str(s) for s in optimized[:5]], reasons  # ìµœëŒ€ 5ê°œ ì„¹ì…˜
    def _find_alternative_section(self, original_section: str, 
                                keywords: List[str]) -> Optional[str]:
        """ëŒ€ì²´ ì„¹ì…˜ ì°¾ê¸°"""
        # ìœ ì‚¬í•œ ëª©ì ì˜ ì„¹ì…˜ ë§¤í•‘
        alternatives = {
            'technical': ['statistics', 'process'],
            'background': ['overview', 'introduction'],
            'challenges': ['solutions', 'future'],
            'benefits': ['impact', 'significance']
        }
        # ë¨¼ì € ì§ì ‘ ë§¤í•‘ëœ ëŒ€ì²´ ì„¹ì…˜ í™•ì¸
        if original_section in alternatives:
            for alt in alternatives[original_section]:
                reliability = self.analytics.get_section_reliability()
                if reliability.get(alt, 0) >= 0.7:
                    return alt
        # í‚¤ì›Œë“œ ê¸°ë°˜ ëŒ€ì²´ ì„¹ì…˜ ì°¾ê¸°
        for keyword in keywords[:2]:
            for section, _ in best_sections:
                if section != original_section:
                    return section
        return None
    def render_full_dashboard(self):
        """ì „ì²´ ë¶„ì„ ëŒ€ì‹œë³´ë“œ (ë³„ë„ íƒ­ì—ì„œ í‘œì‹œ)"""
        st.header("ğŸ“Š ì¹´ë“œë‰´ìŠ¤ ì„¹ì…˜ ë¶„ì„ ëŒ€ì‹œë³´ë“œ")
        
        # ë¶„ì„ ê¸°ê°„ ì„ íƒ
        col1, col2 = st.columns([2, 1])
        with col1:
            date_range = st.date_input(
                "ë¶„ì„ ê¸°ê°„",
                value=(datetime.now() - timedelta(days=7), datetime.now()),
                format="YYYY-MM-DD"
            )
        
        with col2:
            if st.button("ğŸ”„ ë°ì´í„° ìƒˆë¡œê³ ì¹¨"):
                st.rerun()
        
        # ì£¼ìš” ì§€í‘œ
        st.markdown("### ğŸ“ˆ ì£¼ìš” ì§€í‘œ")
        metrics_cols = st.columns(4)
        
        data = self.analytics.load_data()
        total_cards = len(data.get('selections', []))
        avg_sections = sum(len(s['sections']) for s in data.get('selections', [])) / max(total_cards, 1)
        top_section = max(data.get('section_counts', {}).items(), key=lambda x: x[1])[0] if data.get('section_counts') else 'N/A'
        
        with metrics_cols[0]:
            st.metric("ì´ ì¹´ë“œë‰´ìŠ¤", f"{total_cards}ê°œ")
        
        with metrics_cols[1]:
            st.metric("í‰ê·  ì„¹ì…˜ ìˆ˜", f"{avg_sections:.1f}ê°œ")
        
        with metrics_cols[2]:
            st.metric("ìµœë‹¤ ì‚¬ìš© ì„¹ì…˜", self.config.SECTIONS.get(top_section, {}).get('title', top_section))
        
        with metrics_cols[3]:
            quality_score = self._calculate_average_quality_score()
            st.metric("í‰ê·  í’ˆì§ˆ ì ìˆ˜", f"{quality_score:.1f}/10")
        
        # ì„¹ì…˜ë³„ ì‚¬ìš© ì¶”ì´
        st.markdown("### ğŸ“Š ì„¹ì…˜ë³„ ì‚¬ìš© ì¶”ì´")
        usage_data = self._prepare_usage_trend_data(data)
        if not usage_data.empty:
            fig = px.line(
                usage_data,
                x='date',
                y='count',
                color='section',
                title='ì¼ë³„ ì„¹ì…˜ ì‚¬ìš© í˜„í™©',
                labels={'count': 'ì‚¬ìš© íšŸìˆ˜', 'date': 'ë‚ ì§œ', 'section': 'ì„¹ì…˜'}
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # í‚¤ì›Œë“œ-ì„¹ì…˜ ìƒê´€ê´€ê³„
        st.markdown("### ğŸ”— í‚¤ì›Œë“œ-ì„¹ì…˜ ìƒê´€ê´€ê³„")
        correlation_matrix = self.analytics.get_keyword_section_correlation()
        if correlation_matrix:
            self._render_correlation_heatmap(correlation_matrix)
        
        # ì„¹ì…˜ ì„±ëŠ¥ ë¶„ì„
        st.markdown("### ğŸ¯ ì„¹ì…˜ ì„±ëŠ¥ ë¶„ì„")
        performance_data = self._analyze_section_performance()
        if performance_data:
            fig = go.Figure(data=[
                go.Bar(
                    x=list(performance_data.keys()),
                    y=list(performance_data.values()),
                    marker_color='lightblue'
                )
            ])
            fig.update_layout(
                title='ì„¹ì…˜ë³„ í‰ê·  í’ˆì§ˆ ì ìˆ˜',
                xaxis_title='ì„¹ì…˜',
                yaxis_title='í‰ê·  ì ìˆ˜'
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # ê°œì„  ì œì•ˆ
        st.markdown("### ğŸ’¡ ê°œì„  ì œì•ˆ")
        suggestions = self._generate_improvement_suggestions()
        for suggestion in suggestions:
            st.info(suggestion)
    
    def _calculate_average_quality_score(self) -> float:
        """í‰ê·  í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°"""
        if not PLOTLY_AVAILABLE:
            return {}
        feedback = data.get('quality_feedback', [])
        if not feedback:
            return 7.0  # ê¸°ë³¸ê°’
        total_score = sum(f.get('overall_rating', 7) for f in feedback)
        return total_score / len(feedback)
    def _prepare_usage_trend_data(self, data: Dict) -> pd.DataFrame:
        """ì‚¬ìš© ì¶”ì´ ë°ì´í„° ì¤€ë¹„"""
        selections = data.get('selections', [])
        if not selections:
            return pd.DataFrame()
        trend_data = []
        for selection in selections:
            date = datetime.fromisoformat(selection['timestamp']).date()
            for section in selection['sections']:
                trend_data.append({
                    'date': date,
                    'section': self.config.SECTIONS.get(section, {}).get('title', section),
                    'count': 1
                })
        df = pd.DataFrame(trend_data)
        if df.empty:
            return df
        return df.groupby(['date', 'section']).sum().reset_index()
    def _render_correlation_heatmap(self, correlation_matrix: Dict):
        """í‚¤ì›Œë“œ-ì„¹ì…˜ ìƒê´€ê´€ê³„ íˆíŠ¸ë§µ"""
        # ë°ì´í„° ì¤€ë¹„
        keywords = list(correlation_matrix.keys())
        sections = list(set(s[0] for kw_data in correlation_matrix.values() for s in kw_data))
        z_data = []
        for keyword in keywords:
            row = []
            for section in sections:
                # í•´ë‹¹ í‚¤ì›Œë“œì˜ ì„¹ì…˜ ì°¾ê¸°
                value = 0
                kw_sections = correlation_matrix.get(keyword, [])
                for s, score in kw_sections:
                    if s == section:
                        value = score
                        break
                row.append(value)
            z_data.append(row)
        # íˆíŠ¸ë§µ ìƒì„±
        fig = go.Figure(data=go.Heatmap(
            z=z_data,
            x=[self.config.SECTIONS.get(s, {}).get('title', s) for s in sections],
            y=keywords,
            colorscale='Blues'
        ))
        fig.update_layout(
            title='í‚¤ì›Œë“œ-ì„¹ì…˜ ìƒê´€ê´€ê³„',
            xaxis_title='ì„¹ì…˜',
            yaxis_title='í‚¤ì›Œë“œ'
        st.plotly_chart(fig, use_container_width=True)
    def _analyze_section_performance(self) -> Dict[str, float]:
        """ì„¹ì…˜ë³„ ì„±ëŠ¥ ë¶„ì„"""
        section_scores = {}
        section_counts = {}
        for fb in feedback:
            for section, rating in fb.get('section_ratings', {}).items():
                if section not in section_scores:
                    section_scores[section] = 0
                    section_counts[section] = 0
                section_scores[section] += rating
                section_counts[section] += 1
        # í‰ê·  ê³„ì‚°
        performance = {}
        for section in section_scores:
            performance[self.config.SECTIONS.get(section, {}).get('title', section)] = \
                section_scores[section] / section_counts[section]
        return performance
    def _generate_improvement_suggestions(self) -> List[str]:
        """ê°œì„  ì œì•ˆ ìƒì„±"""
        suggestions = []
        # 1. ì €ì„±ëŠ¥ ì„¹ì…˜ ë¶„ì„
        low_performing = [s for s, r in reliability.items() if r < 0.5]
        if low_performing:
            suggestions.append(
                f"âš ï¸ ë‹¤ìŒ ì„¹ì…˜ë“¤ì˜ ì‹ ë¢°ë„ê°€ ë‚®ìŠµë‹ˆë‹¤: "
                f"{', '.join(self.config.SECTIONS.get(s, {}).get('title', s) for s in low_performing[:3])}. "
                f"ì‚¬ìš©ì„ ì¬ê²€í† í•˜ê±°ë‚˜ ëŒ€ì²´ ì„¹ì…˜ì„ ê³ ë ¤í•˜ì„¸ìš”."
        # 2. ë¯¸ì‚¬ìš© ê³ ì„±ëŠ¥ ì„¹ì…˜
        used_sections = set(data.get('section_counts', {}).keys())
        all_sections = set(self.config.SECTIONS.keys())
        unused = all_sections - used_sections
        if unused:
                f"ğŸ’¡ ë‹¤ìŒ ì„¹ì…˜ë“¤ì„ í™œìš©í•´ë³´ì„¸ìš”: "
                f"{', '.join(self.config.SECTIONS.get(s, {}).get('title', s) for s in list(unused)[:3])}"
        # 3. ìµœì  ì¡°í•© ì œì•ˆ
        best_combo = self._find_best_section_combination()
        if best_combo:
                f"ğŸ¯ ìµœê³  ì„±ëŠ¥ ì„¹ì…˜ ì¡°í•©: "
                f"{', '.join(self.config.SECTIONS.get(s, {}).get('title', s) for s in best_combo)}"
        return suggestions
    def _find_best_section_combination(self) -> List[str]:
        """ìµœì  ì„¹ì…˜ ì¡°í•© ì°¾ê¸°"""
        # ë†’ì€ í‰ê°€ë¥¼ ë°›ì€ ì„¹ì…˜ ì¡°í•© ì°¾ê¸°
        high_rated_combos = []
            if fb.get('overall_rating', 0) >= 8:
                # í•´ë‹¹ article_idì˜ selection ì°¾ê¸°
                for selection in data.get('selections', []):
                    if selection.get('article_id') == fb.get('article_id'):
                        high_rated_combos.append(selection['sections'])
        if not high_rated_combos:
            return []
        # ê°€ì¥ ìì£¼ ë‚˜íƒ€ë‚˜ëŠ” ì„¹ì…˜ ì°¾ê¸°
        from collections import Counter
        section_freq = Counter()
        for combo in high_rated_combos:
            for section in combo:
                section_freq[section] += 1
        # ìƒìœ„ 3-4ê°œ ì„¹ì…˜ ë°˜í™˜
        return [s[0] for s in section_freq.most_common(4)]
def extend_section_analytics():
    """SectionAnalytics í´ë˜ìŠ¤ì— ì¶”ê°€ ë©”ì„œë“œ ì£¼ì…"""
    def save_quality_feedback(self, article_id: str, overall_rating: int, 
                            section_ratings: Dict[str, int], timestamp: str):
        """í’ˆì§ˆ í”¼ë“œë°± ì €ì¥"""
        data = self.load_data()
        if 'quality_feedback' not in data:
            data['quality_feedback'] = []
        data['quality_feedback'].append({
            'article_id': article_id,
            'overall_rating': overall_rating,
            'section_ratings': section_ratings,
            'timestamp': timestamp
        })
        self.save_data(data)
    def get_section_reliability(self) -> Dict[str, float]:
        """ì„¹ì…˜ë³„ ì‹ ë¢°ë„ ê³„ì‚° (0-1)"""
            # í”¼ë“œë°±ì´ ì—†ìœ¼ë©´ ì‚¬ìš© ë¹ˆë„ ê¸°ë°˜ ê³„ì‚°
            total_uses = sum(data.get('section_counts', {}).values())
            if total_uses == 0:
                return {s: 0.5 for s in self.config.SECTIONS.keys()}
            return {
                section: min(count / (total_uses * 0.2), 1.0)
                for section, count in data.get('section_counts', {}).items()
            }
        # í”¼ë“œë°± ê¸°ë°˜ ì‹ ë¢°ë„ ê³„ì‚°
            overall = fb.get('overall_rating', 7)
                
                # ì „ì²´ í‰ì ê³¼ ì„¹ì…˜ í‰ì ì˜ ê°€ì¤‘ í‰ê· 
                weighted_score = (rating * 0.7 + overall * 0.3) / 10
                section_scores[section] += weighted_score
        reliability = {}
        for section in self.config.SECTIONS.keys():
            if section in section_counts and section_counts[section] > 0:
                reliability[section] = section_scores[section] / section_counts[section]
                reliability[section] = 0.5  # ê¸°ë³¸ê°’
        return reliability
    # ë©”ì„œë“œ ì£¼ì…
    SectionAnalytics.save_quality_feedback = save_quality_feedback
    SectionAnalytics.get_section_reliability = get_section_reliability
# ëª¨ë“ˆ ë¡œë“œ ì‹œ ìë™ìœ¼ë¡œ í™•ì¥
extend_section_analytics()
# í˜¸í™˜ì„±ì„ ìœ„í•œ í•¨ìˆ˜
def get_analytics_handler():
    """ë¶„ì„ í•¸ë“¤ëŸ¬ ë°˜í™˜ (í˜¸í™˜ì„± ìœ ì§€)"""
    if PLOTLY_AVAILABLE:
        return AnalyticsDashboard()
    else:
